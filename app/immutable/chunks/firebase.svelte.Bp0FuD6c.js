var w=Object.defineProperty;var L=t=>{throw TypeError(t)};var E=(t,s,e)=>s in t?w(t,s,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[s]=e;var a=(t,s,e)=>E(t,typeof s!="symbol"?s+"":s,e),y=(t,s,e)=>s.has(t)||L("Cannot "+e);var i=(t,s,e)=>(y(t,s,"read from private field"),e?e.call(t):s.get(t)),r=(t,s,e)=>s.has(t)?L("Cannot add the same private member more than once"):s instanceof WeakSet?s.add(t):s.set(t,e);import{p as o}from"./proxy.DWE3J2IR.js";import{R as x,T as P,n,o as u,q as c,V as f,W as U}from"./runtime.zjbhdcTH.js";import{g as F,d as m,c as D,o as _,a as A,e as R,u as T}from"./app.svelte.Bs1Ymz2A.js";const v=(t,s=300)=>{let e;return(...b)=>{clearTimeout(e),e=setTimeout(()=>{t.apply(void 0,b)},s)}},B=1e3;var h,l,d,g,p;class N{constructor(){a(this,"app",F());r(this,h,n(null));r(this,l,n(!0));r(this,d,n(!1));r(this,g,n(o({})));r(this,p,n(0));a(this,"unsubscribers",[]);a(this,"authChange",s=>{this.user=s,s?(console.warn("Logged in, subscribing to docs"),this.unsubscribers.push(this.syncUserDoc())):(console.warn("Logged out, unsubscribing from docs"),this.unsubscribers.forEach(e=>e()),this.unsubscribers=[])});a(this,"debounced_publish",v(async s=>{if(!this.user){console.warn("Not logged in, cannot publish user doc to firestore");return}this.isPublishing=!0;const e=m(D,"users",this.user.uid);try{console.log("Publishing app data to firestore"),await T(e,s)}catch(b){console.error("Error while publishing user doc to firestore",b)}finally{this.isPublishing=!1}},B));f(()=>{this.app.getUserUpdatableStates(),U(()=>{this.isLoading||(this.lastLocalUpdate=Date.now())})}),f(()=>{this.isLoading||(this.userDoc.lastUpdated===void 0||this.lastLocalUpdate>this.userDoc.lastUpdated?U(()=>{const s=this.app.export();this.publish({...s,lastUpdated:this.lastLocalUpdate})}):this.userDoc.lastUpdated>this.lastLocalUpdate?(console.log("Updated app data"),U(()=>{this.app.update(this.userDoc)})):this.userDoc.lastUpdated===this.lastLocalUpdate&&console.log("firestore user doc and app are in sync"))}),f(()=>{const s=A.onAuthStateChanged(this.authChange);return()=>{console.warn("Closing Firebase"),this.unsubscribers.forEach(e=>e()),this.unsubscribers=[],s()}})}get user(){return u(i(this,h))}set user(s){c(i(this,h),o(s))}get isLoading(){return u(i(this,l))}set isLoading(s){c(i(this,l),o(s))}get isPublishing(){return u(i(this,d))}set isPublishing(s){c(i(this,d),o(s))}get userDoc(){return u(i(this,g))}set userDoc(s){c(i(this,g),o(s))}get lastLocalUpdate(){return u(i(this,p))}set lastLocalUpdate(s){c(i(this,p),o(s))}syncUserDoc(){if(!this.user)throw new Error("Cannot sync firestore user doc, user is null");const s=m(D,"users",this.user.uid);return _(s,e=>{this.isLoading=!1,e.exists()?(console.log("Fetched firestore user doc"+(e.metadata.hasPendingWrites||e.metadata.fromCache?" (local)":"")),this.userDoc=e.data()):(console.log("Creating firestore user doc"),R(s,{},{merge:!0}))},e=>{console.error("Error while fetching firestore user doc",e)})}publish(s){this.isPublishing=!0,this.debounced_publish(s)}}h=new WeakMap,l=new WeakMap,d=new WeakMap,g=new WeakMap,p=new WeakMap;const C=Symbol("firebase"),q=()=>{const t=new N;return x(C,t)},I=()=>P(C);export{I as g,q as s};
